---
layout: post

title: "Python Entry Points Explained"
tagline: "Using entry points as a modular plug-in architecture"
categories:
author: "Ishan Srivastava"
permalink: /pyconindia19/
---

# Abstract

In this talk I’m going to explain about entry points in Python. Most people know entry points as the little snippet that you put in your setup.py file to make your package available as a script on the command line, but they can be used for so much more. I’m going to show you how to use entry points as a modular plug-in architecture. This is super useful if you want to let other people write Python packages that interact or add abilities to your existing Python package at runtime.

```
!! WARNING: TERRIBLE HUMOR AHEAD !!
```

# Snek, Inc.

Congratulations! You have just been appointed CEO of “Snek Semiconductors and Software, Incorporated”. You first job as CEO is, obviously, to instruct your R&D department to develop a snek prototype ASAP. And so, they get to work, writing snek.py:

```python
ascii_snek = """\
    --..,_                     _,.--.
       `'.'.                .'`__ o  `;__.
          '.'.            .'.'`  '---'`  `
            '.`'--....--'`.'
              `'--....--'`
"""

def main():
    print(ascii_snek)
    
if __name__ == '__main__':
    main()
```

Their prototype was displayed at the company demo day, and it worked!

```
$ python snek.py
    --..,_                     _,.--.
       `'.'.                .'`__ o  `;__.
          '.'.            .'.'`  '---'`  `
            '.`'--....--'`.'
              `'--....--'`
```

# SaaS - Snek as a Service

Unfortunately, customers don’t know about Python (except for the snek). They want easy access to snek from any path in the shell without needing to worry about this Python thing, or finding snek.py. So the gals over at R&D worked all night and came up with a way to package snek in a way that automagically creates a console script when it’s installed. When you create a distribution for a Python package, you need to have a setup.py file that contains the package’s name, dependencies, etc. It can also be used to register entry points and it looks like this:

```python
class FilterClass(type):
    def __prepare__(name, bases, **kwds):
        return collections.OrderedDict()
```
        

This way, when the class will be created, an `OrderedDict` will be used to host the namespace, allowing us to keep the definition order. Please note that the signature `__prepare__(name, bases, **kwds)` is enforced by the language. If you want the method to get the metaclass as a first argument (because the code of the method needs it) you have to change the signature to `__prepare__(metacls, name, bases, **kwds)` and decorate it with `@classmethod`.

The second function we want to define in our metaclass is `__new__`. Just like happens for the instantiation of classes, this method is invoked by Python to get a new instance of the metaclass, and is run before `__init__`. Its signature has to be `__new__(metacls, name, bases, namespace, **kwds)` and the result shall be an instance of the metaclass. As for its normal class counterpart (after all a metaclass is a class), `__new__()` usually wraps the same method of the parent class, `type` in this case, adding its own customizations.

The customization we need is the creation of a list of methods that are marked in some way (the decorated filters). Say for simplicity's sake that the decorated methods have an attribute `_filter`.

The full metaclass is then

```python
class FilterClass(type):
    @classmethod
    def __prepare__(name, bases, **kwds):
        return collections.OrderedDict()

    def __new__(metacls, name, bases, namespace, **kwds):
        result = type.__new__(metacls, name, bases, dict(namespace))
        result._filters = [
            value for value in namespace.values() if hasattr(value, '_filter')]
        return result
```

Now we have to find a way to mark all filter methods with a `_filter` attribute.

# The Anatomy of Purple Decorators

**decorate**: *to add something to an object or place, especially in order to make it more attractive* (Cambridge Dictionary)

Decorators are, as the name suggests, the best way to augment functions or methods. Remember that a decorator is basically a callable that accepts another callable, processes it, and returns it.

Used in conjunction with metaclasses, decorators are a very powerful and expressive way to implement advanced behaviours in our code. In this case we may easily use them to add an attribute to decorated methods, one of the most basic tasks for a decorator.

I decided to implement the `@stringfilter` decorator as a function, even if I usually prefer implementing them as classes. The reason is that decorator classes behave differently when used to implement decorators without arguments rather than decorators with arguments. In this case this difference would force to write some complex code and an explanation of that would be overkill now.

The decorator is very simple:

```python
def stringfilter(func):
    func._filter = True
    return func
```

As you can see the decorator just creates an attribute called _filter into the function (remember that functions are objects). The actual value of this attribute is not important in this case, since we are just interested in telling apart class members that contain it.

# The Dynamics of a Callable Object

We are used to think about functions as special language components that may be "called" or executed. In Python functions are objects, just like everything else, and the feature that allows them to be executed comes from the presence of the `__call__()` method. Python is polymorphic by design and based on delegation, so (almost) everything that happens in the code relies on some features of the target object.

The result of this generalization is that every object that contains the `__call__()` method may be executed like a function, and gains the name of *callable object*.

The `StringProcessor` class shall thus contain this method and perform there the string processing with all the contained filters. The code is

```python
class StringProcessor(metaclass=FilterClass):

    def __call__(self, string):
        _string = string
        for _filter in self._filters:
            _string = _filter(self, _string)

        return _string
```

A quick review of this simple function shows that it accepts the string as an argument, stores it in a local variable and loops over the filters, executing each of them on the local string, that is on the result of the previous filter.

The filter functions are extracted from the `self._filters list`, that is compiled by the `FilterClass` metaclass we already discussed.

What we need to do now is to inherit from `StringProcessor` to get the metaclass machinery and the `__call__()` method, and to define as many methods as needed, decorating them with the `@stringfilter` decorator.

Note that, thanks to the decorator and the metaclass, you may have other methods in your class that do not interfere with the string processing as long as they are not decorated with the decorator under consideration.

An example derived class may be the following

```python
class MyStringProcessor(StringProcessor):

    @stringfilter
    def capitalize(self, string):
        return string.capitalize()

    @stringfilter
    def remove_double_spaces(self, string):
        return string.replace(' ', ' ')
```

The two `capitalize()` and `remove_double_spaces()` methods have been decorated, so they will be applied in order to any string passed when calling the class. A quick example of this last class is

```bash
>>> import strproc
>>> msp = strproc.MyStringProcessor()
>>> input_string = "a test string"
>>> output_string = msp(input_string)
>>> print("INPUT STRING:", input_string)
INPUT STRING: a test string
>>> print("OUTPUT STRING:", output_string)
OUTPUT STRING: A test string
>>> 
```

That's it!

# Final words

There are obviously other ways to accomplish the same task, and this talk wanted just to give a practical example of what metaclasses are good for, and why I think that they should be part of any Python programmer's arsenal.

It is especially interesting to know that some developers consider the use of metaclasses a risky business, because they hide a lot of the structure of the class and the underlying machinery. This is true, so (as you should do for other technologies), think carefully about the reasons that drive you to use metaclasses, and be sure you know them well.
